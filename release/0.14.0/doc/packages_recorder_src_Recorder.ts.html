<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/recorder/src/Recorder.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="packages/recorder/src/Recorder.ts - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/scenejs-render" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h2 class="custom"><a href="https://daybrush.com/scenejs/features.html" target="_blank" class="menu-item" id="features" >Features</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="recorder" class="parent"><a href="Recorder.html">Recorder</a><h4><a href="Recorder.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Recorder.html#setFetchFile">setFetchFile</a></li><li data-type='method'><a href="Recorder.html#setCapturing">setCapturing</a></li><li data-type='method'><a href="Recorder.html#setAnimator">setAnimator</a></li><li data-type='method'><a href="Recorder.html#recordMedia">recordMedia</a></li><li data-type='method'><a href="Recorder.html#record">record</a></li><li data-type='method'><a href="Recorder.html#getRecordInfo">getRecordInfo</a></li><li data-type='method'><a href="Recorder.html#getAudioFile">getAudioFile</a></li><li data-type='method'><a href="Recorder.html#exit">exit</a></li><li data-type='method'><a href="Recorder.html#destroy">destroy</a></li><li data-type='method'><a href="Recorder.html#trigger">trigger</a></li><li data-type='method'><a href="Recorder.html#once">once</a></li><li data-type='method'><a href="Recorder.html#on">on</a></li><li data-type='method'><a href="Recorder.html#off">off</a></li><li data-type='method'><a href="Recorder.html#emit">emit</a></li></ul><h4><a href="Recorder.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Recorder.html#.event:processVideoStart">processVideoStart</a></li><li data-type='event'><a href="Recorder.html#.event:processVideoEnd">processVideoEnd</a></li><li data-type='event'><a href="Recorder.html#.event:processVideo">processVideo</a></li><li data-type='event'><a href="Recorder.html#.event:processAudioStart">processAudioStart</a></li><li data-type='event'><a href="Recorder.html#.event:processAudioEnd">processAudioEnd</a></li><li data-type='event'><a href="Recorder.html#.event:processAudio">processAudio</a></li><li data-type='event'><a href="Recorder.html#.event:captureStart">captureStart</a></li><li data-type='event'><a href="Recorder.html#.event:captureEnd">captureEnd</a></li><li data-type='event'><a href="Recorder.html#.event:capture">capture</a></li></ul><h4><a href="Recorder.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="Recorder.html#.RenderVideoOptions">RenderVideoOptions</a></li><li data-type='typddef'><a href="Recorder.html#.RenderMediaInfoOptions">RenderMediaInfoOptions</a></li><li data-type='typddef'><a href="Recorder.html#.RecordInfoOptions">RecordInfoOptions</a></li><li data-type='typddef'><a href="Recorder.html#.RecorderOptions">RecorderOptions</a></li><li data-type='typddef'><a href="Recorder.html#.OnRequestCapture">OnRequestCapture</a></li><li data-type='typddef'><a href="Recorder.html#.OnProcessAudioStart">OnProcessAudioStart</a></li><li data-type='typddef'><a href="Recorder.html#.OnProcess">OnProcess</a></li><li data-type='typddef'><a href="Recorder.html#.OnCaptureStart">OnCaptureStart</a></li><li data-type='typddef'><a href="Recorder.html#.OnCapture">OnCapture</a></li><li data-type='typddef'><a href="Recorder.html#.FileType">FileType</a></li></ul></li><li file="eventemitter" class="parent"><a href="EventEmitter.html">EventEmitter</a><h4><a href="EventEmitter.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li><li data-type='method'><a href="EventEmitter.html#once">once</a></li><li data-type='method'><a href="EventEmitter.html#on">on</a></li><li data-type='method'><a href="EventEmitter.html#off">off</a></li><li data-type='method'><a href="EventEmitter.html#emit">emit</a></li></ul><h4><a href="EventEmitter.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="EventEmitter.html#.TargetParam">TargetParam</a></li><li data-type='typddef'><a href="EventEmitter.html#.OnEvent">OnEvent</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventOptions">EventOptions</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventListener">EventListener</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventInfo">EventInfo</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventHash">EventHash</a></li><li data-type='typddef'><a href="EventEmitter.html#.EmitterParam">EmitterParam</a></li></ul></li></ul><ul class="namespaces"><li file="render" class="parent"><a href="Render.html">Render</a><h4><a href="Render.html#static methods">Static Methods</a></h4><ul class='static methods'><li data-type='method'><a href="Render.html#.render">render</a></li></ul><h4><a href="Render.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="Render.html#.RenderOptions">RenderOptions</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">packages/recorder/src/Recorder.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Scene, { Animator, AnimatorOptions } from "scenejs";
import { MediaSceneInfo } from "@scenejs/media";
import { FileType, OnCapture, OnRequestCapture, OnProcess, RecordInfoOptions, RenderVideoOptions, RenderMediaInfoOptions, RecorderOptions, OnCaptureStart, OnProcessAudioStart } from "./types";
import { createFFmpeg, fetchFile, FFmpeg } from "@ffmpeg/ffmpeg";
import EventEmitter from "@scena/event-emitter";
import { createTimer, hasProtocol, isAnimator, resolvePath } from "./utils";


export const DEFAULT_CODECS = {
    mp4: "libx264",
    webm: "libvpx-vp9",
};

/**
 * A recorder that captures the screen and creates a video or audio file
 * @example
import Recorder, { OnRequestCapture } from "@scenjs/recorder";
import Scene from "scenejs";

const scene = new Scene();
const recorder = new Recorder();

recorder.setAnimator(scene);
recorder.setCapturing("png", (e: OnRequestCapture) => {
    scene.setTime(e.time, true);
    // html to image
    return htmlToImage(element);
});

recorder.record().then(data => {
  const url = URL.createObjectURL(new Blob(
    [data.buffer],
    { type: 'video/mp4' },
  ));

  video.setAttribute("src", url);
  recorder.destroy();
});
 */
export class Recorder extends EventEmitter&lt;{
    captureStart: OnCaptureStart;
    capture: OnCapture;
    captureEnd: {};
    processVideoStart: Required&lt;RenderVideoOptions>;
    processVideo: OnProcess;
    processVideoEnd: {};
    processAudioStart: OnProcessAudioStart;
    processAudio: OnProcess;
    processAudioEnd: {};
}> {
    protected _animator!: Animator;
    protected _imageType!: "jpeg" | "png";
    protected _ffmpeg!: FFmpeg;
    protected _ready!: Promise&lt;void>;
    protected _hasMedia!: boolean;
    protected _fetchFile: (data: FileType) => Promise&lt;Uint8Array | null> = fetchFile;
    protected _capturing!: (e: OnRequestCapture) => Promise&lt;FileType> | FileType;
    /**
     *
     */
    constructor(private _options: RecorderOptions = {}) {
        super();
    }
    /**
     * Set up a function to import files. Defaults to fetchData from `@ffmpeg/ffmpeg`
     * @sort 1
     */
    public setFetchFile(fetchFile: (data: FileType) => Promise&lt;Uint8Array | null>) {
        this._fetchFile = fetchFile;
    }
    /**
     * Set the function to get the image to be captured per frame.
     * @sort 1
     * @param - image extension of the file
     * @param - A function that returns the image to be captured per frame.
     */
    public setCapturing(
        imageType: "jpeg" | "png",
        capturing: (e: OnRequestCapture) => Promise&lt;FileType> | FileType,
    ) {
        this._imageType = imageType;
        this._capturing = capturing;
    }
    /**
     * Set the animator to record.
     * @sort 1
     */
    public setAnimator(animator: Animator | Partial&lt;AnimatorOptions>) {
        this._animator
            = isAnimator(animator)
                ? animator
                : new Animator(animator);
    }
    /**
     * Get the result of audio processing.
     * @sort 1
     */
    public getAudioFile(): Uint8Array {
        return this._ffmpeg.FS("readFile", "merge.mp3");
    }
    /**
     * Start audio processing.
     * @sort 1
     * @param mediaInfo - media info
     * @param options - media info options
     * @returns {$ts:Promise&lt;Uint8Array>}
     */
    public async recordMedia(mediaInfo: MediaSceneInfo, options?: RenderMediaInfoOptions) {
        let length = 0;
        const medias = mediaInfo.medias;
        const duration = mediaInfo.duration;

        if (!duration || !medias) {
            return;
        }
        const ffmpeg = await this.init();

        await medias.reduce(async (pipe, media) => {
            await pipe;
            const url = media.url;
            const seek = media.seek;
            const delay = media.delay;
            const playSpeed = media.playSpeed;
            const volume = media.volume;

            const path = hasProtocol(url) ? url : resolvePath(options?.inputPath ?? "", url);
            const [startTime, endTime] = seek;
            const fileName = path.match(/[^/]+$/g)?.[0] ?? path;


            await this.writeFile(fileName, path);
            await ffmpeg.run(
                "-ss", `${startTime}`,
                "-to", `${endTime}`,
                "-i", fileName,
                "-filter:a", `adelay=${delay * playSpeed * 1000}|${delay * playSpeed * 1000},atempo=${playSpeed},volume=${volume}`,
                `audio${length++}.mp3`,
            );
        }, Promise.resolve());

        if (!length) {
            return;
        }

        const files = ffmpeg.FS("readdir", "./");
        const audios = files.filter(fileName => fileName.match(/audio[\d]+.mp3/));
        const audiosLength = audios.length;

        if (!audiosLength) {
            return;
        }
        const inputOption: string[] = [];
        const timer = createTimer();

        /**
         * The event is fired when audio process starts.
         * @memberof Recorder
         * @event processAudioStart
         * @param {Recorder.OnProcessAudioStart} - Parameters for the `processAudioStart` event
         */
        this.emit("processAudioStart", {
            audiosLength,
        });
        audios.forEach(fileName => {
            inputOption.push("-i", fileName);
        });
        ffmpeg.setProgress(e => {
            const ratio = e.ratio;
            const {
                currentTime,
                expectedTime,
            } = timer.getCurrentInfo(e.ratio);
            /**
             * The event is fired when audio processing is in progress.
             * @memberof Recorder
             * @event processAudio
             * @param {Recorder.OnProcess} - Parameters for the `processAudio` event
             */
            this.emit("processAudio", {
                currentProcessingTime: currentTime,
                expectedProcessingTime: expectedTime,
                ratio,
            });
        });
        await ffmpeg.run(
            ...inputOption,
            "-filter_complex", `amix=inputs=${audiosLength}:duration=longest`,
            "merge.mp3",
        );
        /**
         * The event is fired when audio process ends.
         * @memberof Recorder
         * @event processAudioEnd
         */
        this.emit("processAudioEnd");
        if (ffmpeg.FS("readdir", "./").indexOf("merge.mp3") >= 0) {
            this._hasMedia = true;

            return this.getAudioFile();
        }
    }
    /**
     * Start capturing and video processing.
     * @sort 1
     * @param options - record options
     * @returns {$ts:Promise&lt;Uint8Array>}
     */
    public async record(options: RenderVideoOptions &amp; RecordInfoOptions = {}) {
        const recordInfo = this.getRecordInfo(options);

        const rootStartFrame = recordInfo.startFrame;
        const rootEndFrame = recordInfo.endFrame;
        const imageType = this._imageType;
        const totalFrame = rootEndFrame - rootStartFrame + 1;
        const fps = options.fps || 60;
        let frameCount = 0;
        await this.init();

        const timer = createTimer();
        /**
         * The event is fired when capture starts.
         * @memberof Recorder
         * @event captureStart
         * @param {Recorder.OnCaptureStart} - Parameters for the `captureStart` event
         */
        this.emit("captureStart", {
            startFame: rootStartFrame,
            endFrame: rootEndFrame,
            startTime: recordInfo.startTime,
            endTime: recordInfo.endTime,
            duration: recordInfo.duation,
            multi: options.multi || 1,
            imageType,
            fps,
        });
        await Promise.all(recordInfo.loops.map((loop, workerIndex) => {
            let pipe = Promise.resolve();
            const startFrame = loop.startFrame;
            const endFrame = loop.endFrame;

            for (let i = startFrame; i &lt;= endFrame; ++i) {
                const callback = ((currentFrame: number) => {
                    return async () => {
                        const time = currentFrame / fps;
                        const data = await this._capturing({
                            workerIndex,
                            frame: currentFrame,
                            time,
                        });

                        await this.writeFile(`frame${currentFrame - rootStartFrame}.${imageType}`, data);
                        ++frameCount;

                        const ratio = frameCount / totalFrame;
                        const {
                            currentTime: currentCapturingTime,
                            expectedTime: expectedCapturingTime,
                        } = timer.getCurrentInfo(ratio);
                        /**
                         * The event is fired when frame capturing is in progress.
                         * @memberof Recorder
                         * @event capture
                         * @param {Recorder.OnCapture} - Parameters for the `capture` event
                         */
                        this.emit("capture", {
                            ratio,
                            frameCount,
                            totalFrame,
                            frameInfo: {
                                frame: currentFrame,
                                time,
                            },
                            currentCapturingTime,
                            expectedCapturingTime,
                        });
                    };
                })(i);
                pipe = pipe.then(callback);
            }
            return pipe;
        }));

        /**
         * The event is fired when capture ends.
         * @memberof Recorder
         * @event captureEnd
         */
        this.emit("captureEnd");
        return await this.renderVideo({
            ...options,
            duration: recordInfo.duation,
        });
    }
    /**
     * Get the information to be recorded through options.
     * @sort 1
     */
    public getRecordInfo(options: RecordInfoOptions) {
        const animator = this._animator;
        const inputIteration = options.iteration;
        const inputDuration = options.duration || 0;
        const inputStartTime = options.startTime || 0;
        const inputFPS = options.fps || 60;
        const inputMulti = options.multi || 1;
        const sceneIterationCount = inputIteration || animator.getIterationCount();
        const sceneDelay = animator.getDelay();
        const playSpeed = animator.getPlaySpeed();
        const duration = animator.getDuration();
        let iterationCount = 0;

        if (sceneIterationCount === "infinite") {
            iterationCount = inputIteration || 1;
        } else {
            iterationCount = inputIteration || sceneIterationCount;
        }
        const totalDuration = sceneDelay + duration * (iterationCount);
        const endTime = inputDuration > 0
            ? Math.min(inputStartTime + inputDuration, totalDuration)
            : totalDuration;
        const startTime = Math.min(inputStartTime, endTime);
        const startFrame = Math.floor(startTime * inputFPS / playSpeed);
        const endFrame = Math.ceil(endTime * inputFPS / playSpeed);
        const dist = Math.ceil((endFrame - startFrame) / (inputMulti || 1));
        const loops: Array&lt;{
            startFrame: number;
            endFrame: number;
        }> = [];

        for (let i = 0; i &lt; inputMulti; ++i) {
            loops.push({
                startFrame: startFrame + dist * i + (i === 0 ? 0 : 1),
                endFrame: startFrame + dist * (i + 1),
            });
        }

        return {
            duation: (endTime - startTime) / playSpeed,
            loops,
            iterationCount,
            startTime,
            endTime,
            startFrame,
            endFrame,
        }
    }
    public async init() {
        this._ffmpeg = this._ffmpeg || createFFmpeg({ log: this._options.log });

        const ffmpeg = this._ffmpeg;


        if (!this._ready) {
            this._ready = ffmpeg.load();
        }

        await this._ready;
        return ffmpeg;
    }
    public async writeFile(fileName: string, file: string | Buffer | File | Blob) {
        await this.init();

        const data = await this._fetchFile(file);

        if (!data) {
            return;
        }
        this._ffmpeg.FS("writeFile", fileName, data);
    }
    public async renderVideo(options: RenderVideoOptions) {
        const {
            ext = "mp4",
            fps = 60,
            codec,
            duration,
            bitrate: bitrateOption,
            cpuUsed,
        } = options;

        const hasMedia = this._hasMedia;
        const parsedCodec = codec || DEFAULT_CODECS[ext || "mp4"] || DEFAULT_CODECS.mp4;
        const bitrate = bitrateOption || "4096k";
        const inputOption = [
            "-i", `frame%d.${this._imageType}`,
        ];
        const audioOutputOpion: string[] = [];
        const outputOption = [
            `-cpu-used`, `${cpuUsed || 8}`,
            "-pix_fmt", "yuva420p",
        ];


        if (ext === "webm") {
            outputOption.push(
                "-row-mt", "1",
            );
        }
        if (hasMedia) {
            inputOption.push(
                "-i", "merge.mp3",
            );
            audioOutputOpion.push(
                "-acodec", "aac",
                // audio bitrate
                '-b:a', "128k",
                // audio channels
                "-ac", "2",
            );
        }

        const ffmpeg = await this.init();


        const timer = createTimer();
        /**
         * The event is fired when process video starts.
         * @memberof Recorder
         * @event processVideoStart
         * @param {Recorder.OnProcessVideoStart} - Parameters for the `processVideoStart` event
         */
        this.emit("processVideoStart", {
            ext,
            fps,
            codec: parsedCodec,
            duration,
            bitrate,
            cpuUsed,
        });
        ffmpeg.setProgress(e => {
            const ratio = e.ratio;
            const {
                currentTime,
                expectedTime,
            } = timer.getCurrentInfo(e.ratio);
            /**
             * The event is fired when frame video processing is in progress.
             * @memberof Recorder
             * @event processVideo
             * @param {Recorder.OnProcess} - Parameters for the `processVideo` event
             */
            this.emit("processVideo", {
                currentProcessingTime: currentTime,
                expectedProcessingTime: expectedTime,
                ratio,
            });
        });

        await ffmpeg!.run(
            `-r`, `${fps}`,
            ...inputOption,
            ...audioOutputOpion,
            `-c:v`, parsedCodec,
            `-loop`, `1`,
            `-t`, `${duration}`,
            "-y",
            `-b:v`, bitrate,
            ...outputOption,
            `output.${ext}`,
        );
        /**
         * The event is fired when process video ends
         * @memberof Recorder
         * @event processVideoEnd
         */
        this.emit("processVideoEnd");
        return ffmpeg!.FS('readFile', `output.${ext}`);
    }
    /**
     * Quit ffmpeg.
     * @sort 1
     */
    public exit() {
        try {
            this._ffmpeg?.exit();
        } catch (e) {

        }
        this._ffmpeg = null;
    }
    /**
     * Remove the recorder and ffmpeg instance.
     * @sort 1
     */
    public destroy() {
        this.off();
        this.exit();
    }
}
</code></pre>
        </article>
    </section>





<style>


nav li[file="packages/recorder/src/recorder"]:after {
    display: none;
}
nav li[file="packages/recorder/src/recorder"] h4, nav li[file="packages/recorder/src/recorder"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.4.4</a> on Sat Dec 31 2022 16:06:20 GMT+0900 (대한민국 표준시) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
